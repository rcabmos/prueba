<!doctype html>
<html lang="es">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>6. Gráficas posición-tiempo por tramos | Movimiento Rectilíneo y Uniforme </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="author" content="Rafael Cabrera Moscoso" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-13"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Saltar la navegación</a></p>
<header id="header" ><div id="headerContent">Movimiento Rectilíneo y Uniforme</div></header>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Movimiento Rectilíneo Uniforme</a></li>
   <li><a href="1_cmo_sabemos_que_un_cuerpo_se_est_moviendo.html" class="daddy">1. ¿Cómo sabemos que un cuerpo se está moviendo?</a>
   <ul class="other-section">
      <li><a href="12_posicin.html" class="daddy">1.2 Posición</a>
      <ul class="other-section">
         <li><a href="activiades_de_posicin.html" class="no-ch">Activiades de posición</a></li>
      </ul>
      </li>
      <li><a href="13_trayectoria_distancia_recorrida_y_desplazamiento.html" class="no-ch">1.3 Trayectoria, distancia recorrida y desplazamiento</a></li>
   </ul>
   </li>
   <li><a href="2_velocidad.html" class="daddy">2. Velocidad</a>
   <ul class="other-section">
      <li><a href="21_cambio_de_unidades.html" class="daddy">2.1 Cambio de unidades</a>
      <ul class="other-section">
         <li><a href="actividades_conversin_velocidad.html" class="no-ch">Actividades Conversión Velocidad</a></li>
      </ul>
      </li>
      <li><a href="22_actividades.html" class="no-ch">2.2 Actividades</a></li>
   </ul>
   </li>
   <li><a href="3_movimiento_rectilneo_uniforme_mru.html" class="daddy">3. Movimiento rectilíneo uniforme (MRU)</a>
   <ul class="other-section">
      <li><a href="actvidades.html" class="no-ch">Actvidades</a></li>
   </ul>
   </li>
   <li><a href="4__grficas_posicintiempo.html" class="daddy">4  Gráficas posición-tiempo</a>
   <ul class="other-section">
      <li><a href="411_actividad_informacin_grfica_posicintiempo.html" class="no-ch">4.1.1 Actividad: Información gráfica posición-tiempo</a></li>
      <li><a href="412_actividad_construye_una_grfica_a_partir_de_una_tabla.html" class="no-ch">4.1.2 Actividad: Construye una gráfica a partir de una tabla</a></li>
      <li><a href="413_actividad_construye_una_grfica_a_partir_de_la_ecuacin_de_posicin.html" class="no-ch">4.1.3 Actividad: Construye una gráfica a partir de la ecuación de posición</a></li>
   </ul>
   </li>
   <li><a href="5_posicin_relativa_de_dos_vehculos.html" class="daddy">5. Posición relativa de dos vehículos</a>
   <ul class="other-section">
      <li><a href="actividad_posicin_relativa_de_dos_vehculos.html" class="no-ch">Actividad: Posición relativa de dos vehículos</a></li>
   </ul>
   </li>
   <li id="active"><a href="6_grficas_posicintiempo_por_tramos.html" class="active no-ch">6. Gráficas posición-tiempo por tramos</a></li>
   <li><a href="7_sda.html" class="daddy">7. SdA</a>
   <ul class="other-section">
      <li><a href="ficha_didctica.html" class="no-ch">Ficha Didáctica</a></li>
   </ul>
   </li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="actividad_posicin_relativa_de_dos_vehculos.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="7_sda.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">6. Gráficas posición-tiempo por tramos</h1></header>
<article class="iDevice_wrapper textIdevice em_iDevice" id="id169">
<div class="iDevice emphasis1" >
<header class="iDevice_header iDevice_header_noIcon"><h1 class="iDeviceTitle">Gráficas por tramos</h1></header>
<div class="iDevice_inner">
<div class="iDevice_content_wrapper">
<div id="ta169_135_2" class="block iDevice_content">
<div class="exe-text"><p><img src="img1.2.png" width="188" height="110" alt="grafica_tramos" style="float: left; margin-right: 12px; margin-left: 12px;" />La siguiente animación te permite <strong>crear la gráfica por tramos</strong> a partir de los <strong>datos de posición y tiempo</strong> que hallarás en la <strong>tabla</strong>. Tendrás que <span style="color: #ff0000;"><strong>mover los puntos con el cursor</strong></span> hasta situarlos en la posición adecuada. Finalmente, cuando ya los tengas alineados, podrás contestar a las preguntas para describir el movimiento de la gráfica.  </p>
<div id="eXeLearning_interactive_container">
<div id="main-interactive">
<div id="table-container-interactive">
<table id="data-table-interactive">
<thead>
<tr id="t-row-interactive">
<th>Tiempo (s)</th>
</tr>
</thead>
<tbody>
<tr id="x-row-interactive">
<th>Posición (m)</th>
</tr>
</tbody>
</table>
</div>
<div id="controls-interactive"><button id="new-problem-btn-interactive">Nuevo Problema</button> <button id="toggle-grid-btn-interactive">Ocultar Cuadrícula</button> <button id="export-pdf-btn-interactive">Exportar a PDF</button></div>
<div id="message-interactive">¡Felicidades! Has colocado todos los puntos correctamente.</div>
<div id="graph-container-interactive"><canvas id="canvas-interactive" width="800" height="400"></canvas> <img id="logo" src="nombreserendipia.jpg" alt="Logo" /></div>
<div id="questions-interactive">
<h2>Preguntas</h2>
<ol>
<li>Analiza las características del movimiento en cada tramo: dirección, sentido y rapidez.</li>
<li>Construye una tabla que recoja la posición del coche cada 10 s.</li>
<li>Haz un esquema con las posiciones del coche y explica cómo ha sido su movimiento.</li>
<li>¿El coche termina su recorrido donde lo empezó? Explica tu respuesta.</li>
<li>Razona si la velocidad ha sido la misma durante todo del movimiento. ¿Y en cada uno de los tramos?</li>
</ol>
</div>
</div>
</div>
<p>
<script>
// Función para encapsular la lógica principal, ideal para eXe-Learning
function initializeInteractiveGraph() {
    const canvas = document.getElementById('canvas-interactive');
    const ctx = canvas.getContext('2d');
    const padding = 50; // Padding for the graph
    const numPointsInteractive = 10; // Number of data points (0s to 90s for 10 points)
    const timesInteractive = Array.from({ length: numPointsInteractive }, (_, i) => i * 10); // Time points (0, 10, 20...)

    // --- Global State Variables ---
    let positionsInteractive = []; // Will store calculated positions
    let circlesInteractive = []; // Stores draggable circle objects
    let draggingInteractive = null; // Index of the currently dragged circle
    let showGrid = true; // State for grid visibility
    let cutsInteractive = []; // Store segment cut points

    const thresholdInteractive = 15; // Proximity for correct placement
    const segmentColors = ['#007bff', '#28a745', '#ffc107', '#dc3545', '#6f42c1']; // Blue, Green, Yellow, Red, Purple
    const correctPointColor = '#00a000'; // Green for correct points
    const incorrectPointColor = '#a00707'; // Red for incorrect/unmoved points

    // --- Data Generation Function ---
    function generateNewProblem() {
        const MAX_RANGE_X = 150; // Maximum allowed range for X values
        let validProblemGenerated = false;

        while (!validProblemGenerated) {
            // Generate random segments for varied motion
            cutsInteractive = [0]; // Reset cuts
            const numSegs = Math.floor(Math.random() * 3) + 3; // 3 to 5 segments
            while (cutsInteractive.length < numSegs) {
                const r = Math.floor(Math.random() * (numPointsInteractive - 1)) + 1;
                if (!cutsInteractive.includes(r)) cutsInteractive.push(r);
            }
            cutsInteractive.push(numPointsInteractive - 1); // Ensure last point is a cut
            cutsInteractive.sort((a, b) => a - b); // Sort cuts to ensure correct segment order

            const dtInteractive = timesInteractive[1] - timesInteractive[0]; // Time interval between points
            positionsInteractive = Array(numPointsInteractive).fill(0); // Reset positions array
            
            // Initial position (random integer between -75 and 75, roughly half of MAX_RANGE_X)
            positionsInteractive[0] = Math.floor(Math.random() * (MAX_RANGE_X / 2 + 1)) - Math.floor(MAX_RANGE_X / 4);

            // Calculate positions for each segment
            for (let s = 0; s < cutsInteractive.length - 1; s++) {
                const start = cutsInteractive[s];
                const end = cutsInteractive[s + 1];
                // Velocity range from -7 to 7 m/s (integers)
                // Max change per step: 7 * 10s = 70m
                const v = Math.floor(Math.random() * 15) - 7; 
                for (let i = start + 1; i <= end; i++) {
                    // Ensure position is always an integer
                    positionsInteractive[i] = positionsInteractive[i - 1] + (v * dtInteractive);
                }
            }

            // Check if the generated range is within the allowed limit
            const minX = Math.min(...positionsInteractive);
            const maxX = Math.max(...positionsInteractive);
            if ((maxX - minX) <= MAX_RANGE_X) {
                validProblemGenerated = true;
            }
        }

        // Populate the data table
        const tRow = document.getElementById('t-row-interactive');
        const xRow = document.getElementById('x-row-interactive');
        
        tRow.innerHTML = '<th>Tiempo (s)</th>';
        xRow.innerHTML = '<th>Posición (m)</th>';
        timesInteractive.forEach((t, i) => {
            tRow.innerHTML += `<td>${t}</td>`;
            xRow.innerHTML += `<td>${positionsInteractive[i]}</td>`; // X values are already integers
        });

        // IMPORTANT: Re-initialize circles AFTER positionsInteractive is updated
        initCirclesInteractive();
        document.getElementById('message-interactive').style.display = 'none'; // Hide success message
        renderInteractive(); // Draw the new graph
    }

    // --- Conversion Functions ---
    // Determine min/max Y for scaling
    function getGraphMinMaxY() {
        const minXVal = Math.min(...positionsInteractive);
        const maxXVal = Math.max(...positionsInteractive);
        
        // The buffer should be smaller since we are controlling the range
        const buffer = (maxXVal - minXVal) * 0.1 || 10; // 10% buffer or a minimum of 10 units
        const graphMinY = Math.floor((minXVal - buffer) / 10) * 10; // Round down to nearest 10
        const graphMaxY = Math.ceil((maxXVal + buffer) / 10) * 10; // Round up to nearest 10
        return { graphMinY, graphMaxY };
    }

    function toCanvasXInteractive(t) {
        const tMax = timesInteractive[timesInteractive.length - 1];
        return padding + (t / tMax) * (canvas.width - 2 * padding);
    }

    function toCanvasYInteractive(x) {
        const { graphMinY, graphMaxY } = getGraphMinMaxY();
        return padding + (canvas.height - 2 * padding) * (1 - (x - graphMinY) / (graphMaxY - graphMinY));
    }

    // Convert canvas Y to data X (position)
    function toDataXInteractive(yCanvas) {
        const { graphMinY, graphMaxY } = getGraphMinMaxY();
        return graphMinY + (1 - (yCanvas - padding) / (canvas.height - 2 * padding)) * (graphMaxY - graphMinY);
    }

    // --- Drawing Functions ---
    function drawAxesInteractive() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

        // Draw grid lines
        if (showGrid) {
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            const tMax = timesInteractive[timesInteractive.length - 1];
            const { graphMinY, graphMaxY } = getGraphMinMaxY();

            // Vertical grid lines (time) - every 10s
            for (let t = 0; t <= tMax; t += 10) {
                const x = toCanvasXInteractive(t);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }

            // Horizontal grid lines (position)
            let stepY = 10;
            const rangeY = graphMaxY - graphMinY;
            // More refined step selection for better grid density
            if (rangeY <= 40) stepY = 5;
            else if (rangeY <= 80) stepY = 10;
            else if (rangeY <= 120) stepY = 20;
            else stepY = 25; // Max step for 150 range

            for (let xv = Math.ceil(graphMinY / stepY) * stepY; xv <= graphMaxY; xv += stepY) {
                const y = toCanvasYInteractive(xv);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }
        }

        // Draw X-axis (time) and Y-axis (position)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;

        // X-axis (line at position 0) - if 0 is within the graph range
        const y0 = toCanvasYInteractive(0);
        if (y0 >= padding && y0 <= canvas.height - padding) {
            ctx.beginPath();
            ctx.moveTo(padding, y0);
            ctx.lineTo(canvas.width - padding, y0);
            ctx.stroke();
        }

        // Y-axis (at time 0)
        const x0 = toCanvasXInteractive(0);
        if (x0 >= padding && x0 <= canvas.width - padding) {
            ctx.beginPath();
            ctx.moveTo(x0, padding);
            ctx.lineTo(x0, canvas.height - padding);
            ctx.stroke();
        }

        // Axis labels
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        
        // Time labels (X-axis)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const tMax = timesInteractive[timesInteractive.length - 1];
        for (let t = 0; t <= tMax; t += 10) {
            ctx.fillText(t + 's', toCanvasXInteractive(t), canvas.height - padding + 5);
        }
        ctx.fillText('t (s)', canvas.width - padding + 20, canvas.height - padding + 5);


        // Position labels (Y-axis)
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        const { graphMinY, graphMaxY } = getGraphMinMaxY();
        let stepY = 10; // Same stepY logic as for grid lines
        const rangeY = graphMaxY - graphMinY;
        if (rangeY <= 40) stepY = 5;
        else if (rangeY <= 80) stepY = 10;
        else if (rangeY <= 120) stepY = 20;
        else stepY = 25;

        for (let xv = Math.ceil(graphMinY / stepY) * stepY; xv <= graphMaxY; xv += stepY) {
            ctx.fillText(Math.round(xv) + 'm', padding - 5, toCanvasYInteractive(xv));
        }
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText('x (m)', padding - 20, padding - 20);
    }

    function drawGraphSegments() {
        const allCorrect = circlesInteractive.every(c => Math.abs(c.y - c.correctY) < thresholdInteractive);

        if (circlesInteractive.length > 0) {
            ctx.lineWidth = 3;

            let segmentColorIndex = 0;
            for (let s = 0; s < cutsInteractive.length - 1; s++) {
                const startIndex = cutsInteractive[s];
                const endIndex = cutsInteractive[s+1];

                ctx.strokeStyle = allCorrect ? segmentColors[segmentColorIndex % segmentColors.length] : '#a00707';

                ctx.beginPath();
                ctx.moveTo(circlesInteractive[startIndex].x, circlesInteractive[startIndex].y);
                for (let i = startIndex + 1; i <= endIndex; i++) {
                    ctx.lineTo(circlesInteractive[i].x, circlesInteractive[i].y);
                }
                ctx.stroke();
                segmentColorIndex++;
            }
        }
    }

    function drawCirclesInteractive() {
        if (circlesInteractive.length === 0) return; // Prevent errors if circles aren't initialized yet

        circlesInteractive.forEach((c) => {
            // Determine color based on proximity to correct position
            const isCorrectlyPlaced = Math.abs(c.y - c.correctY) < thresholdInteractive;
            ctx.beginPath();
            ctx.fillStyle = isCorrectlyPlaced ? correctPointColor : incorrectPointColor;
            ctx.arc(c.x, c.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }

    // --- Initialization and Rendering ---
    function initCirclesInteractive() {
        circlesInteractive.length = 0; // Clear any existing circles
        if (positionsInteractive.length === 0) return; 

        // Get the full range of Y values on the canvas for random initial placement
        const { graphMinY, graphMaxY } = getGraphMinMaxY();
        const canvasMinY = toCanvasYInteractive(graphMaxY); // Top of the graph area
        const canvasMaxY = toCanvasYInteractive(graphMinY); // Bottom of the graph area

        timesInteractive.forEach((t, i) => {
            // Generate a random Y position within the visible graph area (excluding padding)
            // Ensure the random Y is within the draggable bounds (padding to canvas.height - padding)
            const randomY = Math.random() * (canvasMaxY - canvasMinY) + canvasMinY;

            circlesInteractive.push({
                t: t,
                correctY: toCanvasYInteractive(positionsInteractive[i]), // Target Y position
                x: toCanvasXInteractive(t), // Fixed X position based on time
                y: randomY // Start all points at a random Y value
            });
        });
    }

    function renderInteractive() {
        drawAxesInteractive();
        drawGraphSegments();
        drawCirclesInteractive();
    }

    function checkSolutionInteractive() {
        const ok = circlesInteractive.every(c => Math.abs(c.y - c.correctY) < thresholdInteractive);
        document.getElementById('message-interactive').style.display = ok ? 'block' : 'none';
        renderInteractive(); // Re-render to update point colors
    }

    // --- Event Listeners for Interaction ---
    // Get mouse/touch position relative to canvas
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        // Use clientX/Y for mouse events, or touches[0].clientX/Y for touch events
        const clientX = evt.clientX || (evt.touches && evt.touches[0] ? evt.touches[0].clientX : 0);
        const clientY = evt.clientY || (evt.touches && evt.touches[0] ? evt.touches[0].clientY : 0);

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    canvas.addEventListener('pointerdown', e => {
        // Prevent default touch actions (like scrolling) when interacting with canvas
        if (e.pointerType === 'touch') e.preventDefault(); 
        
        const pos = getMousePos(e);
        circlesInteractive.forEach((c, i) => {
            // Check if click/touch is within the circle's radius
            if (Math.hypot(pos.x - c.x, pos.y - c.y) < 15) { // Radius for hit detection
                draggingInteractive = i;
                canvas.style.cursor = 'grabbing';
            }
        });
    });

    canvas.addEventListener('pointermove', e => {
        if (draggingInteractive !== null) {
            // Prevent default touch actions (like scrolling) when dragging
            if (e.pointerType === 'touch') e.preventDefault();

            const pos = getMousePos(e);
            // Only allow vertical movement, and constrain within canvas padding
            circlesInteractive[draggingInteractive].y = Math.max(padding, Math.min(pos.y, canvas.height - padding));
            renderInteractive();
        }
    });

    ['pointerup', 'pointercancel', 'pointerleave'].forEach(evtName => {
        canvas.addEventListener(evtName, (e) => {
            if (draggingInteractive !== null) {
                // No need for e.preventDefault() here, sometimes it can cause issues on pointerup
            }
            draggingInteractive = null;
            canvas.style.cursor = 'grab'; // Reset cursor
            checkSolutionInteractive(); // Re-check solution and update point colors
        });
    });


    // --- Event Handlers for Buttons ---
    document.getElementById('new-problem-btn-interactive').addEventListener('click', generateNewProblem);

    document.getElementById('toggle-grid-btn-interactive').addEventListener('click', () => {
        showGrid = !showGrid;
        document.getElementById('toggle-grid-btn-interactive').textContent = showGrid ? 'Ocultar Cuadrícula' : 'Mostrar Cuadrícula';
        renderInteractive();
    });

    document.getElementById('export-pdf-btn-interactive').addEventListener('click', async () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'mm', 'a4');

        let yOffset = 10;

        // Add Title
        doc.setFontSize(20);
        doc.text("Análisis de Movimiento", 105, yOffset, null, null, "center");
        yOffset += 20;

        // Add Table (convert HTML table to image for better rendering)
        const tableContainer = document.getElementById('table-container-interactive');
        document.getElementById('controls-interactive').style.display = 'none'; // Temporarily hide buttons for screenshot
        // Hide the logo for the table screenshot
        document.getElementById('logo').style.display = 'none'; 
        await html2canvas(tableContainer, { scale: 2 }).then(canvas => {
            const imgData = canvas.toDataURL('image/png');
            const imgWidth = 180;
            const imgHeight = canvas.height * imgWidth / canvas.width;
            if (yOffset + imgHeight > 280) {
                doc.addPage();
                yOffset = 10;
            }
            doc.addImage(imgData, 'PNG', 15, yOffset, imgWidth, imgHeight);
            yOffset += imgHeight + 10;
        });
        document.getElementById('controls-interactive').style.display = 'block'; // Show buttons again


        // Add Graph (Canvas)
        const originalShowGrid = showGrid;
        const originalLogoDisplay = document.getElementById('logo').style.display; // Store original logo state
        showGrid = true; // Force grid on for PDF export
        document.getElementById('logo').style.display = 'block'; // Ensure logo is visible on graph export
        renderInteractive(); // Render with forced grid and visible logo

        await html2canvas(canvas, { scale: 2 }).then(canvas => {
            const imgData = canvas.toDataURL('image/png');
            const imgWidth = 180;
            const imgHeight = canvas.height * imgWidth / canvas.width;
            if (yOffset + imgHeight > 280) {
                doc.addPage();
                yOffset = 10;
            }
            doc.addImage(imgData, 'PNG', 15, yOffset, imgWidth, imgHeight);
            yOffset += imgHeight + 10;
        });
        showGrid = originalShowGrid; // Restore original grid state
        document.getElementById('logo').style.display = originalLogoDisplay; // Restore original logo display state
        renderInteractive(); // Re-render for screen display

        // Add Questions
        const questionsContainer = document.getElementById('questions-interactive');
        await html2canvas(questionsContainer, { scale: 2 }).then(canvas => {
            const imgData = canvas.toDataURL('image/png');
            const imgWidth = 180;
            const imgHeight = canvas.height * imgWidth / canvas.width;
            if (yOffset + imgHeight > 280) {
                doc.addPage();
                yOffset = 10;
            }
            doc.addImage(imgData, 'PNG', 15, yOffset, imgWidth, imgHeight);
        });

        doc.save('Analisis_Movimiento.pdf');
    });

    // Initial setup on page load
    generateNewProblem(); 
}

// Para eXe-Learning: Asegurarse de que el script se ejecute cuando el DOM esté listo
document.addEventListener('DOMContentLoaded', initializeInteractiveGraph);

</script>
</p>
<style>
        /* Estilos generales para eXe-Learning: usar un contenedor principal para aislar */
        #eXeLearning_interactive_container {
            max-width: 800px;
            margin: 0 auto;
            font-family: 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            padding: 20px;
        }
        h1, h2 { text-align: center; color: #556; }
        #table-container-interactive { background: #ffe5e5; padding: 10px; border: 1px solid #e0b4b4; border-radius: 6px; margin-bottom: 20px; }
        #data-table-interactive { width: 100%; border-collapse: collapse; }
        #data-table-interactive th, #data-table-interactive td { padding: 8px; text-align: center; border: 1px solid #ccc; }
        #graph-container-interactive {
            position: relative; /* Muy importante: el contenedor del canvas debe ser relative para el logo */
            background: #ffe5e5;
            padding: 10px;
            border: 1px solid #e0b4b4;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        #canvas-interactive { width: 100%; height: auto; background: #fff; border: 1px solid #ccc; border-radius: 4px; display: block; }
        .draggable-interactive { cursor: grab; }
        #message-interactive { display: none; text-align: center; font-size: 18px; color: #0a5; margin-bottom: 20px; }
        #questions-interactive { background: #ffe5e5; padding: 15px; border: 1px solid #e0b4b4; border-radius: 6px; }
        #questions-interactive ol { padding-left: 20px; }
        #controls-interactive { text-align: center; margin-bottom: 20px; }
        #controls-interactive button {
            padding: 10px 15px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f0f0f0;
            color: #333;
        }
        #controls-interactive button:hover {
            background-color: #e0e0e0;
        }
        /* Estilos para el logo dentro del contenedor de la gráfica */
        #logo {
            position: absolute;
            bottom: 20px; /* Ajustado para que no quede pegado al borde del padding del canvas */
            left: 20px; /* Ajustado para que no quede pegado al borde del padding del canvas */
            max-width: 80px;
            z-index: 10;
        }
    </style>
<!--a=1--><!----comment node----><!--a=1--><!----comment node----><!--a=1--><!----comment node----><!--a=1--><!----comment node----><!--a=1--></div>
</div>
</div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="actividad_posicin_relativa_de_dos_vehculos.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="7_sda.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<p id="made-with-eXe"><a href="https://exelearning.net/" target="_blank" rel="noopener"><span>Creado con eXeLearning<span> (Ventana nueva)</span></span></a></p><script type="text/javascript" src="_style_js.js"></script></body></html>